////////////////////////////////////////////////////////////////////////////////
// tb_fracn09.v
// D.O.B.       : 7/14/19
// Author       : DarkC343
// Description  : Test bench for fracn.v, file generated by fracn09.pl
//                (This can be run from the TCL script run_modelsim09.do)
////////////////////////////////////////////////////////////////////////////////

`timescale 1 fs / 1 fs

module tb_fracn09;
    `define test_ClockDivider 1'b0      // try another type of divider from Walter Baeck
    `define fin 77760000                    // Hz, input frequency
    `define fout 1544000                // Hz, desired output frequency
    `define time_of_report 100 * 1000000
    `define use_output_50 1'b0          // select which output of dut to use
    // for frequency and jitter tests
    // The next four generics are passed to the divider under test
    `define use_phase_accumulator 1'b0
    `define use_recursive_controller 1'b1
    `define minimum_jitter 1'b0
    `define improve_duty_cycle 1'b1

    reg async_reset;        // active high reset
    reg clock;              // input clock
    reg clock_enable;       // active high enable
    wire output_50;         // approx 50% duty cycle
    wire output_pulse;      // high for single clock

    real measured_frequency;    // in Hz.
    real measured_jitter;
    real measured_duty_cycle_min;
    real measured_duty_cycle_avg;
    real measured_duty_cycle_max;

    `define clock_half_period (0.5e15/`fin) * 1
    `define clock_period 2 * `clock_half_period

    `define ideal_ratio `fin/`fout

    ////////////////////////////////////////////////////////////////////////////////
    // Save the results to a file at a certain time (and repeat)
    ////////////////////////////////////////////////////////////////////////////////
    parameter report_file_name = "fracn.rpt";
    integer f;
    initial
        begin
            f = $fopen(report_file_name, "w");
            forever #(`time_of_report)
                begin
                    $fwrite(f, "%0d", measured_frequency);
                    $fwrite(f, "\t");
                    $fwrite(f, "%0d", ((measured_frequency - `fout) / `fout)*1.0); // frequency error
                    $fwrite(f, "\t");
                    $fwrite(f, "%0d", measured_jitter);
                    $fwrite(f, "\t");
                    $fwrite(f, "%0d", measured_duty_cycle_min*100.0);
                    $fwrite(f, "/");
                    $fwrite(f, "%0d", measured_duty_cycle_avg*100.0);
                    $fwrite(f, "/");
                    $fwrite(f, "%0d", measured_duty_cycle_max*100.0);
                    $fwrite(f, "\n");
                end
        end

    ////////////////////////////////////////////////////////////////////////////////
    // Instantiate the divider under test
    ////////////////////////////////////////////////////////////////////////////////
    generate
        if (~`test_ClockDivider)
        begin : select_allan_divider
        fracn dut(
            .async_reset(async_reset),
            .clock(clock),
            .clock_enable(clock_enable),
            .output_50(output_50),
            .output_pulse(output_pulse)
        );
        end
   endgenerate

    ////////////////////////////////////////////////////////////////////////////////
    // Make the test clock signal
    ////////////////////////////////////////////////////////////////////////////////
        // clock generator
    initial
        begin: clock_generator
            clock_enable <= 1'b1;
            clock <= 1'b1;
            forever #(`clock_half_period) clock <= ~clock;
        end

    ////////////////////////////////////////////////////////////////////////////////
    // Make the test reset signal
    ////////////////////////////////////////////////////////////////////////////////

    // reset generator
    initial
        begin: reset_generator
            async_reset <= 1'b1;
            #(`clock_half_period);
            async_reset <= 1'b0;
        end

    ////////////////////////////////////////////////////////////////////////////////
    // Measure the output frequency and jitter
    //
    // The frequency measured will be correct in the long term,
    // but in the short term, jitter will cause slight errors in measurement.
    //
    // Note that the method used will cause long term frequency errors to affect
    // the jitter measurement.
    //
    // We measure either output_50 or output_pulse depending on
    // the value of the use_output_50 generic.
    ////////////////////////////////////////////////////////////////////////////////
    generate
        if (~`use_output_50)
            begin : measure_pulse
                
                always @(posedge async_reset or posedge clock)
                    begin: measure_frequency
                        real   num_outputs;
                        real   num_clocks;
                        time      phase_error;
                        time      max_phase_error;
                        time      min_phase_error;
                        reg waiting;
                        if (async_reset == 1'b1)
                            begin
                                num_outputs = 0;
                                num_clocks = 0;
                                phase_error = 0;
                                max_phase_error = -1 * 1000000000;
                                min_phase_error = 1 * 1000000000;
                                measured_jitter <= 0;
                                waiting = 1'b1;
                            end
                        else 
                            begin
                                if (waiting)
                                    begin
                                        // don't take any measurements until after the first output pulse
                                        if (output_pulse == 1'b1)
                                            waiting = 1'b0;
                                    end
                                else
                                    begin
                                        num_clocks = num_clocks + 1;
                                        if (output_pulse == 1'b1)
                                            begin
                                                num_outputs = num_outputs + 1;
                                                measured_frequency <= ((num_outputs)/(num_clocks)) * `fin;
                                                phase_error = (((num_outputs) * `ideal_ratio) - (num_clocks)) * `clock_period;
                                                if (phase_error > max_phase_error)
                                                    begin
                                                        max_phase_error = phase_error;
                                                        measured_jitter <= max_phase_error - min_phase_error;
                                                    end
                                                if (phase_error < min_phase_error)
                                                    begin
                                                        min_phase_error = phase_error;
                                                        measured_jitter <= max_phase_error - min_phase_error;
                                                    end
                                            end
                                    end
                            end
                    end
            end
    endgenerate

    ////////////////////////////////////////////////////////////////////////////////
    // Measure the min/avg/max duty cycle of the "50%" duty cycle output.
    // Note that times are turned into integers by dividing them by another time,
    // and if we use the (FAQ suggested) value of 1 fs, we will get overflow
    // problems after 2.1 us.  Hence the division by half the clock period.
    ////////////////////////////////////////////////////////////////////////////////

    always @(posedge async_reset or posedge output_50 or negedge output_50)
        begin: measure_duty_cycle
            time      total_time_high;
            time      total_time_low;
            time      last_rising;
            time      last_falling;
            time      pw_high;
            time      pw_low;
            real duty_cycle;
            real duty_cycle_min;
            real duty_cycle_max;
            if (async_reset == 1'b1)
                begin
                    measured_duty_cycle_min <= 0.0;
                    measured_duty_cycle_avg <= 0.0;
                    measured_duty_cycle_max <= 0.0;
                    duty_cycle_min = 1.0;
                    duty_cycle_max = 0.0;
                end
            else
                begin
                    if(output_50 == 1'b1)
                        begin
                            if (last_falling > 0)
                                begin
                                    pw_low = $time - last_falling;
                                    total_time_low = total_time_low + pw_low;
                                    measured_duty_cycle_avg <= (total_time_high/`clock_half_period)/((total_time_high + total_time_low)/`clock_half_period);
                                end
                            last_rising = $time;
                        end
                    if(output_50 == 1'b0)
                        begin
                            if (last_rising > 0)
                                begin
                                    pw_high = $time - last_rising;
                                    total_time_high = total_time_high + pw_high;
                                    if (pw_low > 0)
                                        begin
                                            duty_cycle = (pw_high/`clock_half_period)/((pw_high + pw_low)/`clock_half_period);
                                            if (duty_cycle < duty_cycle_min)
                                                begin
                                                    duty_cycle_min = duty_cycle;
                                                    measured_duty_cycle_min <= duty_cycle_min;
                                                end
                                            if (duty_cycle > duty_cycle_max)
                                                begin
                                                    duty_cycle_max = duty_cycle;
                                                    measured_duty_cycle_max <= duty_cycle_max;
                                                end
                                        end
                                end
                            last_falling = $time;
                        end
                end
        end

    ////////////////////////////////////////////////////////////////////////////////
    // Process to check that output_50 and output_pulse are the same frequency.
    // (to check that the duty cycle correction doesn't miss pulses, glitch, etc.)
    // Comparison is disabled when output_50 is not driven, as is the case when
    // fin/fout <= 2.  (VHDL gives 'U' and Verilog gives 'Z')
    // There is no explicit test; the error is detected when the variable
    // 'phase_difference' goes out of range.
    // Note that certain versions of Modelsim have the range checking turned off
    // by default.
    ////////////////////////////////////////////////////////////////////////////////

    always @(posedge async_reset or posedge output_50 or posedge clock)
        begin: check_output_phase
            reg [1:0] phase_difference;
            if (async_reset == 1'b1)
                phase_difference = 0;
            else
                begin
                    if(clock == 1'b1)
                        begin
                            if (output_pulse === 1'b1 && output_50 !== 1'bz && output_50 !== 1'bz)
                                phase_difference = phase_difference + 1;
                        end
                    if(output_50 == 1'b1)
                        phase_difference = phase_difference - 1;
                end
        end

endmodule

////////////////////////////////////////////////////////////////////////////////
// <EOF> tb_fracn09.v
////////////////////////////////////////////////////////////////////////////////
